---
title: mysqlTranstction
date: 2019-12-18 21:05:05
tags: mysql,transction
---

### mysql事务
可以说无论去哪里面试mysql的事务和锁一定会被问到的，要回答并答的优雅

#### 事务
事务的概念：易主原子性的sql查询，或者说一个独立的工作单元。如果数据引擎能成功的对数据库应用该组查询的全部语句，那么就执行改组查询，如果其中一条语句因为其他原因无法执行，那么所有的语句都不会执行。事务内的语句要不全部执行，要么全部执行失败。（原子性我理解就是保证一系列操作像最基本的原子一样不能被拆分不能分开成功）

必须注意的是:**事务是在一系列能力和基础功能下实现的，如果系统没有经过ACID的严格测试，空谈事务是没有意义的。**

##### 原子性（atomicity）
一个事务必须呗是谓一个不可分割的最小工作单元，整个事务中的所有操作要么**全部提交成功**，要么**全部失败回滚**，对于一个事务，不可能只执行其中的一部分这就是事务的原子性。
还是上面加黑的那句话，事务的定义也是基于原子性的，没有实现原子性就不会达成事务的定义

##### 一致性（consistency）
数据库总是从一个一致性的状态转换到另一个一致性状态，即使执行到一半一桶崩溃事务中的修改也不会保存到数据中。

#### 隔离性（isolation）
正常来说一个事务所做的提交在最终提交以前，对其它的事务应该**通常**是不可见的**数据库的事务隔离级别会影响可见性**

#### 持久性 (durability)
事务做了提交，所有修改就会永久的保存到数据库中。即使系统崩溃，锁保存的数据也不会丢失。持久性是个模糊的概念，因为实际上持久性有很多级别。有些持久性策略能够提供安全的保障，有些则不能。
例如：可以把系统提交数据倒数据库的数据想成存入到银行的钱，银行有很多安全措施，比放在家里安全，但是如果银行破产了或钱被抢劫啦怎么办。可能就要考虑做各种容灾，数据的冗余备份，没有百分之百的持久性我们只能应该用各种方法尽量保证数据的持久性和可恢复性。

##### 事务小节
综上所述，数据库为了我们数据的安全做了这么多的努力和工作，一个实现了ACID的数据库，肯定需要更大的内存和磁盘空间，更强的cpu能力。
我们唯一要做好的就是根据自己的业务是否需要事务处理来选择合适的存储引擎，以获得更高的性能。及时引擎不支持事务也可以通过lock Tables 为应用提供一定程度的保护，如果这点程度都做不到，真的不好意思称自己为工程师。

#### 事务的隔离级别
上面在说隔离性的时候提到了一个事务在提交之前，其它事务应该是通常不可见的，注意是通常不过sql标准为了应对我门的一些业务场景做了四种隔离界别

##### 事务的隔离界别
隔离级别比想象跟复杂，SQL标准汇中定义了四种隔离级别，每一种级别都详细规定了一个事务中所做的修改在其它事务内和事务间是可见的，那些是不可兼得的，较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

##### READ UNCOMMITED （未递交读）
未提交读中如果事务做了修改即使没有提交，其它事务也是可以看见的。事务妒忌未提交的数据被称为脏读。照成问题的同时并未提高性能，所以一般在应用中很少使用。

##### READ CIMMITED （提交读）
一个事务开始到未提交之前，可以看到其它事务在此期间做的修改。也可以称为不可重复读（因为在事务中，两次读取的数据可能被其它事务修改）

##### REPEATABLE READ（可重复度）
可重复读解决了脏读的问题，保证了在同一事务中多次读取同样的记录结果是一致的。但是还是会产生幻读
幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。
（InnoDbhe 和XtraDb）通过多版本并发控制（mvcc）解决了幻读问题。

##### SERIALIZABLE(可串行化)
SERIALIZABLE是最高的隔离界别，通过强制事务串行执行，避免了幻读，但是会照成大量的锁竞争，非常需要保证数据一致性切没有可以接受并发的情况下，考虑使用该级别。
